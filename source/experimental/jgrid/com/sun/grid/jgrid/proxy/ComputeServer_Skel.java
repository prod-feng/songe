/*************************************************************************
 * 
 *  The Contents of this file are made available subject to the terms of
 *  the Sun Industry Standards Source License Version 1.2
 * 
 *  Sun Microsystems Inc., March, 2001
 * 
 * 
 *  Sun Industry Standards Source License Version 1.2
 *  =================================================
 *  The contents of this file are subject to the Sun Industry Standards
 *  Source License Version 1.2 (the "License"); You may not use this file
 *  except in compliance with the License. You may obtain a copy of the
 *  License at http://gridengine.sunsource.net/Gridengine_SISSL_license.html
 * 
 *  Software provided under this License is provided on an "AS IS" basis,
 *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
 *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
 *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
 *  See the License for the specific provisions governing your rights and
 *  obligations concerning the Software.
 * 
 *   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
 * 
 *   Copyright: 2001 by Sun Microsystems, Inc.
 * 
 *   All Rights Reserved.
 * 
 ************************************************************************/
// Skeleton class generated by rmic, do not edit.
// Contents subject to change without notice.

package com.sun.grid.jgrid.proxy;

/** This skeleton is modified to disallow calls to the compute(Computable) method.
 * The corresponding stub should translate all such calls into calls on the
 * compute(Computable, String) method.
 * @author dan.templeton@sun.com
 * @version 1.3
 * @since 0.2.1
 */
public final class ComputeServer_Skel implements java.rmi.server.Skeleton
{
    private static final java.rmi.server.Operation[] operations = {
	new java.rmi.server.Operation("java.io.Serializable compute(com.sun.grid.jgrid.Computable)"),
	new java.rmi.server.Operation("java.io.Serializable compute(com.sun.grid.jgrid.Computable, java.lang.String)"),
	new java.rmi.server.Operation("java.lang.String computeAsynch(com.sun.grid.jgrid.Computable)"),
	new java.rmi.server.Operation("java.lang.String computeAsynch(com.sun.grid.jgrid.Computable, java.lang.String)"),
	new java.rmi.server.Operation("java.io.Serializable getResults(java.lang.String)"),
	new java.rmi.server.Operation("boolean isComplete(java.lang.String)")
    };
    
    private static final long interfaceHash = -8795380537253775019L;
    
		/** Gets the list of operations supported by this skeleton.
		 * @return the list of operations supported by this skeleton
		 */		
    public java.rmi.server.Operation[] getOperations() {
	return (java.rmi.server.Operation[]) operations.clone();
    }
    
		/** Dispatchs an incoming RMI call to the server object.
		 * @param obj the server object
		 * @param call the RMI call object
		 * @param opnum the index of the target method
		 * @param hash the has number of the target method
		 * @throws Exception thrown if the call parameters are incorrect
		 */		
    public void dispatch(java.rmi.Remote obj, java.rmi.server.RemoteCall call, int opnum, long hash)
	throws java.lang.Exception
    {
	if (opnum < 0) {
	    if (hash == 3908630515974072420L) {
		opnum = 0;
	    } else if (hash == -4135601629327455121L) {
		opnum = 1;
	    } else if (hash == 8164115102769782894L) {
		opnum = 2;
	    } else if (hash == 7821822986407981337L) {
		opnum = 3;
	    } else if (hash == -728148089723471111L) {
		opnum = 4;
	    } else if (hash == -5321554526954319352L) {
		opnum = 5;
	    } else {
		throw new java.rmi.UnmarshalException("invalid method hash");
	    }
	} else {
	    if (hash != interfaceHash)
		throw new java.rmi.server.SkeletonMismatchException("interface hash mismatch");
	}
	
	com.sun.grid.jgrid.proxy.ComputeServer server = (com.sun.grid.jgrid.proxy.ComputeServer) obj;
	switch (opnum) {
	case 0: // compute(Computable)
	{
		throw new java.rmi.RemoteException ("RMI Skeleton has called an invalid method.");
	}
	    
	case 1: // compute(Computable, String)
	{
	    com.sun.grid.jgrid.Computable $param_Computable_1;
	    java.lang.String $param_String_2;
	    try {
		java.io.ObjectInput in = call.getInputStream();
		$param_Computable_1 = (com.sun.grid.jgrid.Computable) in.readObject();
		$param_String_2 = (java.lang.String) in.readObject();
	    } catch (java.io.IOException e) {
		throw new java.rmi.UnmarshalException("error unmarshalling arguments", e);
	    } catch (java.lang.ClassNotFoundException e) {
		throw new java.rmi.UnmarshalException("error unmarshalling arguments", e);
	    } finally {
		call.releaseInputStream();
	    }
	    java.io.Serializable $result = server.compute($param_Computable_1, $param_String_2);
	    try {
		java.io.ObjectOutput out = call.getResultStream(true);
		out.writeObject($result);
	    } catch (java.io.IOException e) {
		throw new java.rmi.MarshalException("error marshalling return", e);
	    }
	    break;
	}
	    
	case 2: // computeAsynch(Computable)
	{
		throw new java.rmi.RemoteException ("RMI Skeleton has called an invalid method.");
	}
	    
	case 3: // computeAsynch(Computable, String)
	{
	    com.sun.grid.jgrid.Computable $param_Computable_1;
	    java.lang.String $param_String_2;
	    try {
		java.io.ObjectInput in = call.getInputStream();
		$param_Computable_1 = (com.sun.grid.jgrid.Computable) in.readObject();
		$param_String_2 = (java.lang.String) in.readObject();
	    } catch (java.io.IOException e) {
		throw new java.rmi.UnmarshalException("error unmarshalling arguments", e);
	    } catch (java.lang.ClassNotFoundException e) {
		throw new java.rmi.UnmarshalException("error unmarshalling arguments", e);
	    } finally {
		call.releaseInputStream();
	    }
	    java.lang.String $result = server.computeAsynch($param_Computable_1, $param_String_2);
	    try {
		java.io.ObjectOutput out = call.getResultStream(true);
		out.writeObject($result);
	    } catch (java.io.IOException e) {
		throw new java.rmi.MarshalException("error marshalling return", e);
	    }
	    break;
	}
	    
	case 4: // getResults(String)
	{
	    java.lang.String $param_String_1;
	    try {
		java.io.ObjectInput in = call.getInputStream();
		$param_String_1 = (java.lang.String) in.readObject();
	    } catch (java.io.IOException e) {
		throw new java.rmi.UnmarshalException("error unmarshalling arguments", e);
	    } catch (java.lang.ClassNotFoundException e) {
		throw new java.rmi.UnmarshalException("error unmarshalling arguments", e);
	    } finally {
		call.releaseInputStream();
	    }
	    java.io.Serializable $result = server.getResults($param_String_1);
	    try {
		java.io.ObjectOutput out = call.getResultStream(true);
		out.writeObject($result);
	    } catch (java.io.IOException e) {
		throw new java.rmi.MarshalException("error marshalling return", e);
	    }
	    break;
	}
	    
	case 5: // isComplete(String)
	{
	    java.lang.String $param_String_1;
	    try {
		java.io.ObjectInput in = call.getInputStream();
		$param_String_1 = (java.lang.String) in.readObject();
	    } catch (java.io.IOException e) {
		throw new java.rmi.UnmarshalException("error unmarshalling arguments", e);
	    } catch (java.lang.ClassNotFoundException e) {
		throw new java.rmi.UnmarshalException("error unmarshalling arguments", e);
	    } finally {
		call.releaseInputStream();
	    }
	    boolean $result = server.isComplete($param_String_1);
	    try {
		java.io.ObjectOutput out = call.getResultStream(true);
		out.writeBoolean($result);
	    } catch (java.io.IOException e) {
		throw new java.rmi.MarshalException("error marshalling return", e);
	    }
	    break;
	}
	    
	default:
	    throw new java.rmi.UnmarshalException("invalid method number");
	}
    }
}
